Αργυρόπουλος
Κωνσταντίνος
1115201500012

Λειτουργικά Συστήματα
Εργασία 1η

Εντολή μεταγλώττισης: make
Εντολή εκτέλεσης: ./simulator x
όπου χ ο αριθμός των εξαρτημάτων που προκύπτουν σε κάθε τμήμα κατασκευής

Αρχεία: Makefile
	simulator.h
	simulator.c
	constructor.c
	painter.c
	controller.c
	assembler.c

simulator.h: Η βιβλιοθήκη στην οποία γίνονται οι δηλώσεις των βιβλιοθηκών του συστήματος που χρησιμοποιούμε, των συναρτήσεων του κάθε αρχείου και των global μεταβλητών, οι οποίες είναι ορατές από όλα τα αρχεία/διεργασίες.

simulator.c: Το αρχείο αυτό είναι ο οδηγός του προγράμματος.Αρχικά, κάνει τους κατάλληλους ελέγχους για τα ορίσματα της γραμμής εντολών. Στη συνέχεια δημιουργεί δομές της κοινής μνήμης και κάνει attach τις μεταβλητές σε αυτή. Οι μεταβλητές αυτές είναι αρκετές και θα δούμε τι κάνει η κάθε μία αργότερα.Στη συνέχεια δημιουργεί τους σημαφόρους που θα χρησιμοποιηθούν στο πρόγραμμά μας, τους οποίους αρχικοποιεί σε 0, ενώ επίσης ορίζει και τις λειτουργίες up και down στους σημαφόρους. Κάνει fork τις 4 βασικές διεργασίες, που αντιστοιχίζονται στα 4 στάδια της γραμμής παραγωγής (κατασκευή,βαφείο,έλεγχος,συναρμολόγηση), και κάθε μια λειτουργεί με μια δική της συνάρτηση σε ένα δικό της αρχείο, όπως θα δούμε στη συνέχεια αναλυτικά.Περιμένει τις διεργασίες να ολοκληρωθούν, εκτυπώνει το μέσο χρόνο αναμονής για την κατάληψη του βαφείου και το μέσο χρόνο που απαιτείται για κάθε προιόν από τη δημιουργεία του πρώτου εξαρτήματος μέχρι την έξοδο του από το στάδιο συναρμολόγησης και τέλος καλεί τη συνάρτηση clear για να γίνουν detach οι δομές από την κοινή μνήμη και για την καταστροφή των σημαφόρων που χρησιμοποιήθηκαν.

constructor.c: Στο αρχείο αυτό εκτελείται η λειτουργία της κατασκευής,με τη χρήση κυρίως 2 συναρτήσεων.

void theConstructor(int products): Η συνάρτηση αυτή λειτουργεί ως οδηγός για την κατασκευή. Αρχικά, δημιουργούνται οι 3 διεργασίες/τύποι των εξαρτημάτων και στη συνέχεια για τη δημιουργεία κάθε εξαρτήματος ο Constructor συντονίζει τις 3 υποδιεργασίες με τους σημαφόρους sem_Constr(περιμένει το εξάρτημα να δημιουργηθεί) και sem_Fits(δίνει εντολή συνέχειας στη διεργασία που έχει φτάσει πρώτη στο σημαφόρο, ώστε να δημιουργήσει το εξάρτημα).Τέλος, αφού δημιουργηθούν όλα τα εξαρτήματα, περιμένει τις διεργασίες να ολοκληρώσουν και κάνει με τη σειρά του και αυτός έξοδο.

void dothejob(int type,int products): Η συνάρτηση αυτή εκτελεί τη δημιουργεία των εξαρτημάτων.Χρησιμοποιείται και από τις 3 διεργασίες(είδη εξαρτημάτων).Αρχικά κάθε διεργασία περιμένει μέχρι ο Constructor να της πει να ξεκινήσει μέσω του σημαφόρου sem_Fits. Όταν η διεργασία (ανεξαρτήτως τύπου) κάνει enter στο σημαφόρο, τότε δημιουργεί το αντικείμενο.Η δημιουργεία γίνεται δίνοντας τιμές στα πεδία της δομής shar_mem. Η shar_mem είναι μια δομή στην κοινή μνήμη, η οποία έχει ως πεδία το id και τον τύπο του εξαρτήματος (ορίζεται στο simulator.h).
Στη συνέχεια, καλείται η συνάρτηση manageTime η οποία επιστρέφει ένα flag που δείχνει αν πρόκειται για ολοκλήρωση προιόντος(3 εξαρτήματα διαφορετικού τύπου-τιμή -1),και όταν φτάσουμε στον συναρμολογητή μετράτε ο χρόνος που πέρασε απο την δημιουργεία του πρώτου εξαρτήματος της συγκεκριμένης τριάδας. Αν η manageTime επιστρέψει 1,τότε έχουμε αρχή νέου προιόντος(νέο εξάρτημα που είναι το πρώτο μιας νέας τριάδας).Στην περίπτωση αυτή ξεκινά το ρολόι να μετρά χρόνο,μέσω 2 μεταβλητών,επίσης στην κοινή μνήμα, του πίνακα timer και του timer_start.Ο timer κρατά στην ουσία διάφορους χρόνους στις θέσεις του, οι οποίες καθορίζονται από τον δείκτη νέου προιόντος που είναι ο timer_start.Περισσότερα για το μέσο χρόνο που απαιτείται για κάθε προιόν από τη δημιουργεία του πρώτου εξαρτήματος μέχρι την έξοδο του από το στάδιο συναρμολόγησης,θα δούμε στην ανάλυση της manageTime αλλά και στον συναρμολογητή.
Όταν ένα νέο προιόν ξεκινά, μαζί του αρχίζει να τρέχει και ένα ρολόι στη μεταβλητή start, το οποίο ολοκληρώνεται αμέσως πριν ξεκινήσει να λειτουργεί το βαφείο.Η τιμή του ρολογιού προσμετράται στην μεταβλητή της κοινής μνήμης paintingAVG, η οποία υπολογίζει τον μέσο χρόνο αναμονής για την κατάληψη του βαφείου.
Επίσης, ξεκινώντας υπάρχει μια καθυστέρηση μέχρι ένα δευτερόλεπτο, που δείχνει τους τυχαίους χρόνους παρασκευής ενός νέου εξαρτήματος.
Στη συνέχεια, κάθε εξάρτημα απελευθερώνει το σημαφόρο sem_Paint επιτρέποντας στο βαφείο να ξεκινήσει τη δουλειά του, και το περιμένει να τελειώσει κάνοντας enter στο sem_Fits1, ώστε να είναι σίγουρο ότι το βαφείο θα είναι ελεύθερο την επόμενη φορά που θα σταλθεί εκεί ένα εξάρτημα.
Τέλος, επιτρέπει και στον Constructor να συνεχίζει απελευθερόνοντας τον σημαφόρο sem_Constr. Πριν ολοκληρώσει η κάθε διεργασία σταματάει (raise(SIGSTOP)),ώστε να μην χαθούν οι δομές που έχει επεξεργαστεί πριν ολοκληρωθούν και οι υπόλοιπες διεργασίες.Ο Constructor είναι αυτός που της λέει να συνεχίσει και να ολοκληρώσει την εκτέλεση της.

Βοηθητικές συναρτήσεις τους αρχείου είναι οι int getId(int products) και int manageTime(int type).
int getId(int products): Επιστρέφει ένα τυχαίο id μέσω της μεταβλητής κοινής μνήμης randId.Το id πέρνει τιμές στο διάστημα [1000,9999] (τυχαίο και 4ψήφιο).
int manageTime(int type): Όπως αναφέραμε και προηγουμένως η συνάρτηση αυτή επιστρέφει ένα flag,πιθανές τιμές του οποίου είναι -1,0,1, και η σημασία τους έχει να κάνει με το αν το νέο εξάρτημα είναι το νέο μια νέας τριάδας ή το τελευταίο μιας ήδη υπάρχουσας.Ο αλγόριθμος που εκτελέι είναι ο εξής:
Καταρχάς,στην κοινή μνήμη υπάρχουν οι μεταβλητές cntA,cntB και cntC,οι οποίες λειτουργούν ως μετρητές για τα εξαρτήματα τα οποία έχουν κατασκευαστεί για προιόντα που δεν είναι ακόμα ολοκληρωμένα. Αν λοιπόν, το προιόν που δημιουργείται (με βάση το είδος του) αυξάνει ή δημιουργεί μέγιστο σε κάποιον από τους μετρητές,αυτό σημαίνει ότι το εξάρτημα αυτό είναι το πρώτο σε μια νέα 3αδα και επιστρέφεται 1.Αν ο μετρητής του εξαρτήματος αυτού του τύπου είναι 0 και οι 2 άλλοι μετρητές έχουν τιμή, τότε με την δημιουργεία του ολοκληρώνεται το προιόν, μειώνουμε κατά 1 τους άλλους 2 μετρητές και επιστρέφουμε -1.Σε άλλη περίπτωση επιστρέφεται 0.

painter.c: Στο αρχείο αυτό εκτελείται η λειτουργία του βαφείου,με τη χρήση 2 συναρτήσεων.

void thePainter(int products): Η συνάρτηση αυτή εκτελεί τον οδηγό του βαφείου. Περιμένει κάθε νέο εξάρτημα μέσω του σημαφόρου sem_Paint και όταν ολοκληρώνει απελευθερώνει το σημαφόρο sem_Fits1,ώστε να συνεχίσει η κατασκευή.Τραβάει από την κοινή μνήμη (shar_mem) το είδος του εξαρτήματος και ανάλογα με αυτόν το βάφει μέσω της συνάρτησης paintIt.Στη συνέχεια απελευθερώνει το σημαφόρο sem_Cont, ώστε να γίνει η λειτουργία του ελέγχου και περιμένει μέχρι να ολοκληρωθεί αυτός.

void paintIt(int type): Η συνάρτησει αυτή "βάφει" το νέο εξάρτημα,περιμένοντας ανάλογα με τον τύπο του κάποιο σταθερό χρόνο.

controller.c: Στο αρχείο αυτό εκτελείται η λειτουργία του ελέγχου,με τη χρήση 4 συναρτήσεων.

void theController(int products): Η συνάρτηση αυτή εκτελεί τον οδηγό του ελέγχου. Αρχικά,κάνει fork τις 3 διεργασίες που αντιστοιχούν στα στάδια του ελέγχου.Στη συνέχεια περιμένει από το βαφείο να απελευθερώσει το σημαφόρο sem_Cont, που σημαίνει ότι βρέθηκε νέο εξάρτημα. Ανάλογα με τον τύπο του εξαρτήματος απελευθερώνεται ο σημαφόρος της αντίστοιχη διεργασίας(contrA,contrΒ,contrC).Στη συνέχεια με τη χρήση 3 μετρητών που δείχνουν πόσα εξαρτήματα έχει η κάθε διεργασία(τύπος ελεγκτή),ελέγχει αν δημιουργείται νέο προιόν.Σε αυτήν την περίπτωση κάνει την μεταβλητή κοινής μνήμης toBeEnq ίση με 0 και ενεργοποιεί όλους τους ελεγκτές για να περάσουν τα εξαρτήματά τους στην κοινή μνήμη contrToAss όπως θα δούμε και στη συνέχεια πιο αναλυτικά.Ξανακάνει την toBeEnq ίση με 1 και απελευθερώνει το σημαφόρο sem_Ass,ώστε να ξεκινήσει τη λειτουργία του ο συναρμολογητής, τον οποίο περιμένει να ολοκληρώσει με το σημαφόρο sem_Cont1.Αφού γίνει αυτό επιτρέπει και αυτός με τη σειρά του στο βαφείο να συνεχίσει με το σημαφόρο sem_Paint1.
Τέλος, αφού δημιουργηθούν όλα τα εξαρτήματα, περιμένει τις διεργασίες να ολοκληρώσουν και κάνει με τη σειρά του και αυτός έξοδο.

void contrA(int products)
void contrΒ(int products)
void contrC(int products)

Οι 3 αυτές συναρτήσεις λειτουργούν με τον ίδιο τρόπο, όμως είναι ξεχωριστές,διότι η κάθε μία κρατά έναν δικό της,private, πίνακα με εξαρτήματα του αντίστοιχου τύπου.Η λειτουργία τους είναι εξής:

Αρχικά, δημιουργούν έναν πίνακα fits της δομής fitment, ο οποίος κρατά τα εξαρτήματα από την κοινή μνήμη.Περιμένουν μέχρι να δημιουργηθεί ένα προιόν του τύπου τους μέσω των σημαφόρων sem_Cont00->τύπος Α, sem_Cont10->τύπος Β, sem_Cont20->τύπος Γ.
Στη συνέχεια ελέγχουν αν η μεταβλητή toBeEnq, η οποία δείχνει αν η δουλεία του ελεγκτή είναι να στείλει ένα εξάρτημα στη συναρμολόγηση είναι να το κρατήσει στον πίνακα του.
Αν η toBeEnq είναι 1 κάνουν μια νέα εγγραφή στον πίνακα με το εξάρτημα που υπάρχει στην κοινή μνήμη shar_mem.
Αλλιώς, στον πίνακα contrToAss της δομής fitment ο οποίος έχει 3 θέσεις και είναι στην κοινή μνήμη, περνά ο καθένας τα στοιχεία του εξαρτήματος που διατηρεί. Στη συνέχεια περιμένει ανάλογα με τον τύπο του κάποιο σταθερό χρόνο.
Τέλος, απελευθερώνουν το σημαφόρο (sem_Cont01->τύπος Α, sem_Cont11->τύπος Β, sem_Cont21->τύπος Γ) για να συνεχίσει ο ελεγκτής.Πριν ολοκληρώσει η κάθε διεργασία σταματάει (raise(SIGSTOP)),ώστε να μην χαθούν οι δομές που έχει επεξεργαστεί πριν ολοκληρωθούν και οι υπόλοιπες διεργασίες.Ο Controller είναι αυτός που τους λέει να συνεχίσουν και να ολοκληρώσουν την εκτέλεση τους.
Να σημειωθεί ότι ο κάθε ελεγκτής θα χρησιμοποιηθεί μία φορά για να κρατήσει την πληροφορία των εξαρτημάτων και μία για να την στείλει στο συναρμολογητή(2*products φορές συνολικά).

assembler.c: Στο αρχείο αυτό εκτελείται η λειτουργία της συναρμολόγησης,με τη χρήση μίας συναρτήσης.

void theAssembler(int products): Αρχικά, περιμένει τον έλεγχο να απελευθερώσει το σημαφόρο sem_Ass,που σημαίνει ότι έχουμε στην κοινή μνήμη με τον πίνακα contrToAss 3 νέα εξαρτήματα έτοιμα να συναρμολογηθούν.Τα 3 αυτά εξαρτήματα ενώνουν τα id τους,το οποίο είναι και το id του τελικού προιόντος.Η συναρμολόγηση κάνει κάποιο σταθερό χρόνο για να ολοκληρωθεί και εκτυπώνει το id του νέου,τελικού προιόντος.
Στη συνέχεια προσθέτει στην μεταβλητή της κοινής μνήμης assemblementAVG το χρόνο που πέρασε από τη δημιουργεία του πρώτου εξαρτήματος μέχρι τη δημιουργεία του τελικού προιόντος. Ο δείκτης timer_ptr στον πίνακα timer, έχει να κάνει με το πόσες φορές έχουμε βρεθεί στο συναρμολογητή ώστε να προσμετράται ο αντίστοιχος χρόνος.
Τέλος, απελευθερώνεται ο σημαφόρος sem_Cont1, ώστε να συνεχίσει ο έλεγχος και όταν ολοκληρωθεί η δημιουργεία των προιόντων γίνεται έξοδος από τη διεργασία.

Αποτελέσματα Προσομοίωσης
Παρατηρούμε ότι όσο αυξάνετε ο αριθμός των εξαρτημάτων που προκύπτουν σε κάθε τμήμα κατασκευής
α.Μειώνεται, συνήθως, ο μέσος χρόνος αναμονής για την κατάληψη του βαφείου.
β.Αυξάνεται ο μέσος χρόνος που απαιτείται για κάθε προϊόν από τη δημιουργία του πρώτου εξαρτήματος μέχρι την έξοδό του από το στάδιο συναρμολόγησης.

Συγκεκριμένα, αν Α ο μέσος χρόνος αναμονής για την κατάληψη του βαφείου
και Β ο μέσος χρόνος που απαιτείται για κάθε προϊόν από τη δημιουργία του πρώτου εξαρτήματος μέχρι την έξοδό του από το στάδιο συναρμολόγησης.
Υ=4
Α= 0.000072
Β= 0.000610

Υ=9
Α= 0.000065
B= 0.000650

Υ=16
A= 0.000055
B= 0.000905

Υ=25
A= 0.000053
B= 0.000933

Υ=36
A= 0.000051
B= 0.001004

Υ=49
A= 0.000049
B= 0.001063

Υ=64
A= 0.000049
B= 0.001753

Υ=81
A= 0.000050
B= 0.002516

Υ=100
A= 0.000050
B= 0.002634
